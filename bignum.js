// Generated by CoffeeScript 1.3.1
/*
 *     Bignumber support for javascript.
 *
 *     Copyright (C) 2012    Jason Siefken
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, either version 3 of the License, or
 *     (at your option) any later version.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.    If not, see <http://www.gnu.org/licenses/>.
*/

var BigInt, BigNatural, CHUNK_DIGITS, CHUNK_SIZE, COMPLEX_PERCISION, Complex, ComplexMath, LOG10, trimZeros;

LOG10 = Math.log(10);

CHUNK_SIZE = 10;

CHUNK_DIGITS = Math.round(Math.log(CHUNK_SIZE) / LOG10);

trimZeros = function(array) {
  while (array.length > 0 && array[array.length - 1] === 0) {
    array.pop();
  }
  return array;
};

BigNatural = (function() {

  BigNatural.name = 'BigNatural';

  function BigNatural(num) {
    var arr, chunk, i;
    this.nums = [];
    if (typeof num === "number") {
      while (num >= 1) {
        chunk = num % CHUNK_SIZE;
        this.nums.push(chunk);
        num = (num - chunk) / CHUNK_SIZE;
      }
    } else if (typeof num === "string") {
      i = num.length;
      while (i > 0) {
        this.nums.push(parseInt(num.slice(Math.max(i - CHUNK_DIGITS, 0), i), 10));
        i -= CHUNK_DIGITS;
      }
    } else if (num instanceof Array || num instanceof BigNatural) {
      arr = void 0;
      if (num instanceof Array) {
        arr = num;
      } else {
        arr = num.nums;
      }
      this.nums = trimZeros(arr.slice());
    } else {
      throw {
        name: "Initialization Error"
      };
      ({
        message: "Unknown initialization type " + num
      });
    }
  }

  BigNatural.prototype._constructor = BigNatural;

  BigNatural.prototype.toString = function() {
    var formatChunk;
    formatChunk = function(n) {
      var leading, ret;
      ret = "" + n;
      leading = Array(Math.max(0, CHUNK_DIGITS - ret.length) + 1).join("0");
      return leading + ret;
    };
    if (this.nums.length === 0) {
      return "0";
    }
    return this.nums[this.nums.length - 1] + this.nums.slice(0, this.nums.length - 1).reverse().map(formatChunk).join("");
  };

  BigNatural.prototype._compareArrays = function(a, b) {
    var i;
    if ((a.length === 0 && b.length === 1 && b[0] === 0) || (b.length === 0 && a.length === 1 && a[0] === 0) || (a.length === 0 && b.length === 0)) {
      return 0;
    }
    if (a.length > b.length) {
      return 1;
    } else {
      if (a.length < b.length) {
        return -1;
      }
    }
    i = a.length;
    while (i >= 0) {
      if (a[i] > b[i]) {
        return 1;
      } else {
        if (a[i] < b[i]) {
          return -1;
        }
      }
      i--;
    }
    return 0;
  };

  BigNatural.prototype._sumArraysWithCarry = function(a, b) {
    var carry, chunk, chunkSum, getElm, i, ret;
    getElm = function(array, elm) {
      return (typeof array[elm] === "undefined" ? 0 : array[elm]);
    };
    ret = [];
    carry = 0;
    i = 0;
    while (i < Math.max(a.length, b.length)) {
      chunkSum = getElm(a, i) + getElm(b, i) + carry;
      chunk = chunkSum % CHUNK_SIZE;
      carry = (chunkSum - chunk) / CHUNK_SIZE;
      ret.push(chunk);
      i++;
    }
    if (carry > 0) {
      ret.push(carry);
    }
    return ret;
  };

  BigNatural.prototype._subtractArrays = function(a, b) {
    var complement, sum;
    complement = this._arrayPAdicCompliment;
    sum = this._sumArraysWithCarry;
    return complement(sum(complement(a), b));
  };

  BigNatural.prototype._arrayPAdicCompliment = function(array) {
    return array.map(function(d) {
      return CHUNK_SIZE - d - 1;
    });
  };

  BigNatural.prototype._arrayDivideWithRemainder = function(a, b) {
    var cmp, divChunk, dividand, remainder, _ref;
    if (b.length === 0 || (b.length === 1 && b[0] === 0)) {
      throw {
        name: "Division By Zero Error"
      };
      ({
        message: "Division by zero"
      });
    }
    dividand = [];
    remainder = [];
    cmp = this._compareArrays(a.slice(1), b);
    if (cmp === 0 || cmp === 1) {
      _ref = this._arrayDivideWithRemainder(a.slice(1), b), dividand = _ref[0], remainder = _ref[1];
      remainder.unshift(a[0]);
      a = remainder;
    }
    divChunk = 0;
    cmp = this._compareArrays(a, b);
    while (cmp === 0 || cmp === 1) {
      a = trimZeros(this._subtractArrays(a, b));
      divChunk++;
      cmp = this._compareArrays(a, b);
    }
    dividand.unshift(divChunk);
    return [trimZeros(dividand), a];
  };

  BigNatural.prototype.shift = function(n) {
    var i, ret;
    ret = Array(n);
    i = n - 1;
    while (i >= 0) {
      ret[i] = 0;
      i--;
    }
    return new this._constructor(ret.concat(this.nums));
  };

  BigNatural.prototype.add = function(other) {
    return new this._constructor(this._sumArraysWithCarry(this.nums, other.nums));
  };

  BigNatural.prototype.sub = function(other) {
    var complement, sum;
    complement = this._arrayPAdicCompliment;
    sum = this._sumArraysWithCarry;
    return new this._constructor(complement(sum(complement(this.nums), other.nums)));
  };

  BigNatural.prototype.mul = function(other) {
    var carry, chunk, chunkProduct, currArray, digit, getElm, pos, ret;
    getElm = function(array, elm) {
      if (typeof array[elm] === "undefined") {
        return 0;
      } else {
        return array[elm];
      }
    };
    ret = new this._constructor(0);
    digit = 0;
    while (digit < other.nums.length) {
      currArray = [];
      carry = 0;
      pos = 0;
      while (pos < this.nums.length) {
        chunkProduct = other.nums[digit] * this.nums[pos] + carry;
        chunk = chunkProduct % CHUNK_SIZE;
        carry = (chunkProduct - chunk) / CHUNK_SIZE;
        currArray.push(chunk);
        pos++;
      }
      currArray.push(carry);
      ret = ret.add((new this._constructor(currArray)).shift(digit));
      digit++;
    }
    return ret;
  };

  BigNatural.prototype.mod = function(other) {
    var ret;
    if (other.eq(new this._constructor(0))) {
      return new this._constructor(0);
    }
    ret = new this._constructor(this);
    if (this.nums.length >= other.nums.length + 2) {
      ret = ret.mod(other.shift(1));
    }
    while (ret.gte(other)) {
      ret = new this._constructor(ret.sub(other));
    }
    return ret;
  };

  BigNatural.prototype.gcd = function(other) {
    var a, b, _ref;
    a = this;
    b = other;
    while (!(b.isZero())) {
      _ref = [b, a.mod(b)], a = _ref[0], b = _ref[1];
    }
    return a;
  };

  BigNatural.prototype.div = function(other) {
    return this.divideWithRemainder(other)[0];
  };

  BigNatural.prototype.divideWithRemainder = function(other) {
    var dividand, remainder, _ref;
    _ref = this._arrayDivideWithRemainder(this.nums, other.nums), dividand = _ref[0], remainder = _ref[1];
    return [new this._constructor(dividand), new this._constructor(remainder)];
  };

  BigNatural.prototype.cmp = function(other) {
    return this._compareArrays(this.nums, other.nums);
  };

  BigNatural.prototype.isZero = function() {
    return this.nums.length === 0 || (this.nums.length === 1 && this.nums[0] === 0);
  };

  BigNatural.prototype.isOne = function() {
    return this.nums.length === 1 && this.nums[0] === 1;
  };

  BigNatural.prototype.eq = function(other) {
    return this.cmp(other) === 0;
  };

  BigNatural.prototype.gt = function(other) {
    return this.cmp(other) === 1;
  };

  BigNatural.prototype.lt = function(other) {
    return this.cmp(other) === -1;
  };

  BigNatural.prototype.gte = function(other) {
    var cmp;
    cmp = this.cmp(other);
    return cmp === 1 || cmp === 0;
  };

  BigNatural.prototype.lte = function(other) {
    var cmp;
    cmp = this.cmp(other);
    return cmp === -1 || cmp === 0;
  };

  return BigNatural;

})();

BigInt = (function() {

  BigInt.name = 'BigInt';

  function BigInt(num, sign) {
    this.num;
    this.sign = 1;
    if (typeof num === "number") {
      if (num < 0) {
        this.sign = -1;
        num = -num;
      }
    } else if (typeof num === "string") {
      if (num.charAt(0) === "-") {
        this.sign = -1;
        num = num.slice(1);
      }
    } else if (num instanceof BigNatural) {
      if (sign === -1) {
        this.sign = -1;
      }
      num = num.nums;
    } else {
      if (num instanceof Array ? sign === -1 : void 0) {
        this.sign = -1;
      }
    }
    this.num = new BigNatural(num);
  }

  BigInt.prototype._constructor = BigInt;

  BigInt.prototype.toString = function() {
    var sign;
    sign = (this.sign === 1 ? "" : "-");
    return sign + this.num;
  };

  BigInt.prototype.negate = function() {
    return new this._constructor(this.num, -this.sign);
  };

  BigInt.prototype.abs = function() {
    return new this._constructor(this.num, 1);
  };

  BigInt.prototype.add = function(other) {
    var bigger, sign, smaller, sum;
    sign = void 0;
    if (this.sign === other.sign) {
      sign = this.sign;
      return new this._constructor(this.num.add(other.num), sign);
    } else {
      bigger = void 0;
      smaller = void 0;
      if (this.num.cmp(other.num) === 1) {
        bigger = this.num;
        smaller = other.num;
        sign = this.sign;
      } else {
        bigger = other.num;
        smaller = this.num;
        sign = other.sign;
      }
      sum = bigger.sub(smaller);
      return new this._constructor(sum, sign);
    }
  };

  BigInt.prototype.mul = function(other) {
    var sign;
    sign = this.sign * other.sign;
    return new this._constructor(this.num.mul(other.num), sign);
  };

  BigInt.prototype.div = function(other) {
    return this.divideWithRemainder(other)[0];
  };

  BigInt.prototype.divideWithRemainder = function(other) {
    var dividand, dividandSign, remainder, remainderSign, _ref;
    dividandSign = 1;
    remainderSign = 1;
    if (this.sign === -1 && other.sign === 1) {
      dividandSign = -1;
      remainderSign = -1;
    } else if (this.sign === 1 && other.sign === -1) {
      dividandSign = -1;
      remainderSign = 1;
    } else if (this.sign === -1 && other.sign === -1) {
      dividandSign = 1;
      remainderSign = -1;
    }
    this.sign * other.sign;
    _ref = this.num.divideWithRemainder(other.num), dividand = _ref[0], remainder = _ref[1];
    return [new this._constructor(dividand, dividandSign), new this._constructor(remainder, remainderSign)];
  };

  BigInt.prototype.gcd = function(other) {
    return this.num.gcd(other.num);
  };

  BigInt.prototype.cmp = function(other) {
    if (this.sign > other.sign) {
      return 1;
    } else {
      if (this.sign < other.sign) {
        return -1;
      }
    }
    if (this.sign === 1) {
      return this.num.cmp(other.num);
    } else {
      return -this.num.cmp(other.num);
    }
  };

  BigInt.prototype.isZero = function() {
    return this.nums.length === 0 || (this.nums.length === 1 && this.nums[0] === 0);
  };

  BigInt.prototype.isOne = function() {
    return this.nums.length === 1 && this.nums[0] === 1 && this.sign === 1;
  };

  return BigInt;

})();

COMPLEX_PERCISION = 10e10;

Complex = (function() {

  Complex.name = 'Complex';

  function Complex(re, im) {
    this.re = re;
    this.im = im;
  }

  Complex.prototype._constructor = Complex;

  Complex.prototype.toString = function() {
    var im, imToString, re;
    imToString = function(x) {
      if (x === 1) {
        return "i";
      } else {
        if (x === -1) {
          return "-i";
        }
      }
      return x + "i";
    };
    if (isNaN(this.re) && isNaN(this.im)) {
      return "NaN";
    }
    re = Math.round(this.re * COMPLEX_PERCISION) / COMPLEX_PERCISION;
    im = Math.round(this.im * COMPLEX_PERCISION) / COMPLEX_PERCISION;
    if (re === 0 && im === 0) {
      return "0";
    } else if (im === 0) {
      return "" + re;
    } else {
      if (re === 0) {
        return imToString(im);
      }
    }
    if (im < 0) {
      return re + " - " + imToString(Math.abs(im));
    } else {
      return re + " + " + imToString(im);
    }
  };

  Complex.prototype.isReal = function(a) {
    a = a || this;
    if (Math.abs(a.im) < 1 / COMPLEX_PERCISION) {
      return true;
    }
    return false;
  };

  Complex.prototype.isImaginary = function(a) {
    a = a || this;
    if (Math.abs(a.re) < 1 / COMPLEX_PERCISION) {
      return true;
    }
    return false;
  };

  Complex.prototype.eq = function(other) {
    var im, otherIm, otherRe, re;
    re = Math.round(this.re * COMPLEX_PERCISION) / COMPLEX_PERCISION;
    im = Math.round(this.im * COMPLEX_PERCISION) / COMPLEX_PERCISION;
    otherRe = Math.round(other.re * COMPLEX_PERCISION) / COMPLEX_PERCISION;
    otherIm = Math.round(other.im * COMPLEX_PERCISION) / COMPLEX_PERCISION;
    return re === otherRe && im === otherIm;
  };

  Complex.prototype.add = function(other) {
    return new Complex(this.re + other.re, this.im + other.im);
  };

  Complex.prototype.sub = function(other) {
    return new Complex(this.re - other.re, this.im - other.im);
  };

  Complex.prototype.mul = function(other) {
    var a, b, c, d;
    a = this.re;
    b = this.im;
    c = other.re;
    d = other.im;
    return new Complex(a * c - b * d, a * d + b * c);
  };

  Complex.prototype.div = function(other) {
    var a, abs, b, c, d, denom;
    a = this.re;
    b = this.im;
    c = other.re;
    d = other.im;
    abs = Math.abs;
    if (abs(c) >= abs(d)) {
      denom = c + d * (d / c);
      return new Complex((a + b * (d / c)) / denom, (b - a * (d / c)) / denom);
    } else {
      denom = d + c * (c / d);
      return new Complex((a * (c / d) + b) / denom, (b * (c / d) - a) / denom);
    }
  };

  Complex.prototype.conj = function() {
    return new Complex(this.re, -this.im);
  };

  Complex.prototype.norm = function() {
    var abs, im, re;
    re = this.re;
    im = this.im;
    if (re === 0 && im === 0) {
      return 0;
    }
    abs = Math.abs;
    if (abs(re) >= abs(im)) {
      return abs(re) * Math.sqrt(1 + (im / re) * (im / re));
    }
    if (abs(re) < abs(im)) {
      return abs(im) * Math.sqrt(1 + (re / im) * (re / im));
    }
  };

  Complex.prototype.arg = function() {
    var ret;
    ret = Math.atan2(this.im, this.re);
    return (ret === -Math.PI ? Math.PI : ret);
  };

  return Complex;

})();

ComplexMath = {
  i: new Complex(0, 1),
  minusI: new Complex(0, -1),
  iOverTwo: new Complex(0, 1 / 2),
  one: new Complex(1, 0),
  minusOne: new Complex(-1, 0),
  pi: new Complex(Math.PI, 0),
  equal: function(a, b) {
    return a.eq(b);
  },
  gt: function(a, b) {
    return (a.norm() - b.norm()) > 1 / COMPLEX_PERCISION;
  },
  lt: function(a, b) {
    return (a.norm() - b.norm()) < -1 / COMPLEX_PERCISION;
  },
  gte: function(a, b) {
    return ComplexMath.equal(a, b) || ComplexMath.gt(a, b);
  },
  lte: function(a, b) {
    return ComplexMath.equal(a, b) || ComplexMath.lt(a, b);
  },
  re: function(z) {
    return new Complex(z.re, 0);
  },
  im: function(z) {
    return new Complex(z.im, 0);
  },
  arg: function(z) {
    return new Complex(z.arg(), 0);
  },
  norm: function(z) {
    return new Complex(z.norm(), 0);
  },
  fromPolar: function(mag, arg) {
    var a, b;
    a = mag * Math.cos(arg);
    b = mag * Math.sin(arg);
    return new Complex(a, b);
  },
  floor: function(z) {
    return new Complex(Math.floor(z.re), Math.floor(z.im));
  },
  ceil: function(z) {
    return new Complex(Math.ceil(z.re), Math.ceil(z.im));
  },
  round: function(z) {
    return new Complex(Math.round(z.re), Math.round(z.im));
  },
  mod: function(a, b) {
    var im, re;
    if (a instanceof Array) {
      b = a[1];
      a = a[0];
    }
    re = ((a.re % b.re) + b.re) % b.re;
    im = ((a.im % b.im) + b.im) % b.im;
    if (isNaN(re) && isNaN(im)) {
      return new Complex(NaN, NaN);
    } else if (isNaN(re)) {
      return new Complex(0, im);
    } else {
      if (isNaN(im)) {
        return new Complex(re, 0);
      }
    }
    return new Complex(re, im);
  },
  conj: function(z) {
    return z.conj();
  },
  negate: function(z) {
    return new Complex(-z.re, -z.im);
  },
  sqrt: function(z) {
    var arg, mag;
    mag = z.norm();
    arg = z.arg();
    return ComplexMath.fromPolar(Math.sqrt(mag), arg / 2);
  },
  add: function(a, b) {
    return a.add(b);
  },
  sub: function(a, b) {
    return a.sub(b);
  },
  mul: function(a, b) {
    return a.mul(b);
  },
  div: function(a, b) {
    return a.div(b);
  },
  log: function(z) {
    var arg, mag;
    mag = z.norm();
    arg = z.arg();
    return new Complex(Math.log(mag), arg);
  },
  exp: function(z) {
    var arg, cos, mag, sin;
    mag = z.norm();
    arg = z.arg();
    cos = Math.cos(arg);
    sin = Math.sin(arg);
    return ComplexMath.fromPolar(Math.exp(mag * cos), mag * sin);
  },
  pow: function(a, b) {
    var binaryDigits, buffer, currentPower, exponent, i, _i;
    if (b.isReal() && Math.round(b.re) === b.re && b.re < 10000) {
      exponent = b.re;
      currentPower = a;
      buffer = new Complex(1, 0);
      binaryDigits = Math.floor(Math.log(exponent) / Math.log(2));
      for (i = _i = 0; 0 <= binaryDigits ? _i <= binaryDigits : _i >= binaryDigits; i = 0 <= binaryDigits ? ++_i : --_i) {
        if ((exponent >> i) % 2 === 1) {
          buffer = ComplexMath.mul(buffer, currentPower);
        }
        currentPower = ComplexMath.mul(currentPower, currentPower);
      }
      return buffer;
    }
    return ComplexMath.exp(ComplexMath.mul(ComplexMath.log(a), b));
  },
  factorial: function(z) {
    var accum, x;
    if (!z.isReal() || z.re < -1 / COMPLEX_PERCISION) {
      return new Complex(NaN, NaN);
    }
    x = z.re;
    if (x > 170) {
      return new Complex(Infinity, 0);
    }
    accum = 1;
    while (x > 1) {
      accum = accum * x;
      x = x - 1;
    }
    return new Complex(accum, 0);
  },
  sin: function(z) {
    var twoI;
    twoI = new Complex(0, 2);
    return ComplexMath.div(ComplexMath.sub(ComplexMath.exp(ComplexMath.mul(ComplexMath.i, z)), ComplexMath.exp(ComplexMath.mul(ComplexMath.minusI, z))), twoI);
  },
  cos: function(z) {
    var two;
    two = new Complex(2, 0);
    return ComplexMath.div(ComplexMath.add(ComplexMath.exp(ComplexMath.mul(ComplexMath.i, z)), ComplexMath.exp(ComplexMath.mul(ComplexMath.minusI, z))), two);
  },
  tan: function(z) {
    return ComplexMath.sin(z).div(ComplexMath.cos(z));
  },
  asin: function(z) {
    return ComplexMath.mul(ComplexMath.log(ComplexMath.add(ComplexMath.mul(ComplexMath.i, z), ComplexMath.sqrt(ComplexMath.sub(ComplexMath.one, z.mul(z))))), ComplexMath.minusI);
  },
  acos: function(z) {
    var sq;
    sq = ComplexMath.sqrt(ComplexMath.sub(ComplexMath.one, z.mul(z)));
    return ComplexMath.mul(ComplexMath.log(ComplexMath.add(z, ComplexMath.mul(z, ComplexMath.i))), ComplexMath.minusI);
  },
  atan: function(z) {
    var lgm, lgp;
    lgm = ComplexMath.log(ComplexMath.sub(ComplexMath.one, ComplexMath.mul(ComplexMath.i, z)));
    lgp = ComplexMath.log(ComplexMath.add(ComplexMath.one, ComplexMath.mul(ComplexMath.i, z)));
    return ComplexMath.mul(ComplexMath.iOverTwo, ComplexMath.sub(lgm, lgp));
  },
  atan2: function(a, b) {
    return new Complex(Math.atan2(a.re, b.re), 0);
  },
  sec: function(z) {
    return ComplexMath.one.div(ComplexMath.cos(z));
  },
  csc: function(z) {
    return ComplexMath.one.div(ComplexMath.sin(z));
  },
  cot: function(z) {
    return ComplexMath.one.div(ComplexMath.tan(z));
  },
  sinh: function(z) {
    return ComplexMath.minusI.mul(ComplexMath.sin(ComplexMath.i.mul(z)));
  },
  cosh: function(z) {
    return ComplexMath.cos(ComplexMath.i.mul(z));
  },
  tanh: function(z) {
    return ComplexMath.minusI.mul(ComplexMath.tan(ComplexMath.i.mul(z)));
  },
  asinh: function(z) {
    return ComplexMath.log(z.add(ComplexMath.sqrt(ComplexMath.one.add(z.mul(z)))));
  },
  acosh: function(z) {
    return ComplexMath.log(z.add(ComplexMath.sqrt(ComplexMath.minusOne.add(z.mul(z)))));
  },
  atanh: function(z) {
    return ComplexMath.log(ComplexMath.one.add(z)).sub(ComplexMath.log(ComplexMath.one.sub(z))).div(new Complex(2, 0));
  }
};
