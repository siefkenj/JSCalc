// Generated by CoffeeScript 1.3.1
/*
   Parser for math expressions

   Copyright (C) 2012  Jason Siefken

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

var CONSTANTS, Node, OPERATORS, Parser, deepcopy, getPrecidence, greaterPrecidence;

OPERATORS = {
  infix: {
    "+": 1,
    "-": 1,
    "*": 2,
    "/": 2,
    "//": 2,
    "^": 4,
    "%": 1,
    "=": 0,
    "==": 0,
    "<": 0,
    "<=": 0,
    ">": 0,
    ">=": 0,
    "!=": 0,
    ",": -1,
    "default": 1
  },
  prefix: {
    "-": 2,
    negate: 2,
    "default": 5
  },
  suffix: {
    "!": 3,
    deg: 3,
    "default": 2
  },
  rightAssociative: {
    "^": true,
    "=": true
  }
};

CONSTANTS = {
  pi: true,
  e: true,
  phi: true,
  i: true,
  I: true
};

deepcopy = function(array) {
  if (array instanceof Array) {
    return array.map(deepcopy);
  }
  return array;
};

getPrecidence = function(op) {
  var opType;
  opType = (typeof op.opType === "undefined" ? "infix" : op.opType);
  if (op.value in OPERATORS[opType]) {
    return OPERATORS[opType][op.value];
  } else {
    return OPERATORS[opType]["default"];
  }
};

greaterPrecidence = function(op1, op2) {
  if (op1 == null) {
    return false;
  }
  if (op2 == null) {
    return true;
  }
  if (!(OPERATORS.rightAssociative[op1.value] && OPERATORS.rightAssociative[op2.value])) {
    return getPrecidence(op1) > getPrecidence(op2);
  } else {
    return getPrecidence(op1) >= getPrecidence(op2);
  }
};

Node = (function() {

  Node.name = 'Node';

  function Node(type, token, children) {
    this.type = type;
    this.token = token;
    this.children = children || [];
  }

  Node.prototype.toString = function() {
    var prettyList;
    prettyList = this.children.map(function(item) {
      if (item.type === "number") {
        return "" + item.value;
      }
      return "" + item;
    });
    return this.token.value + "[ " + prettyList.join(",") + " ]";
  };

  return Node;

})();

Parser = (function() {

  Parser.name = 'Parser';

  function Parser(source) {
    this.source = source;
    this.tokens = [];
  }

  Parser.prototype.tokenize = function(source) {
    var lexer, token, tokens;
    source = source || this.source || "";
    lexer = new Lexer(source);
    token = void 0;
    tokens = [];
    while (token = lexer.get()) {
      if (token.type === "identifier") {
        if (token.value in CONSTANTS) {
          token.type = "number";
          token.constant = true;
        } else {
          token.type = "operator";
          token.opType = "prefix";
        }
      }
      tokens.push(token);
    }
    return tokens;
  };

  Parser.prototype.parseRPN = function(source) {
    var argumentList, children, node, token, tokens;
    tokens = this.tokenize(source);
    argumentList = [];
    while (tokens.length > 0) {
      token = tokens.shift();
      if (token.type === "operator") {
        children = void 0;
        node = void 0;
        if (token.value in OPERATORS.infix) {
          children = argumentList.splice(-2, 2);
        } else {
          children = argumentList.splice(-1, 1);
        }
        node = new Node("operator", token, children);
        argumentList.push(node);
      } else {
        argumentList.push(token);
      }
    }
    return argumentList;
  };

  Parser.prototype.parse = function(source) {
    var tokens;
    tokens = this.tokenize(source);
    tokens = this.computeBracketTree(tokens);
    tokens = this.insertImplicitMultiplication(tokens);
    tokens = this.suffixesToPrefixes(tokens);
    return this.computeASTForm(tokens);
  };

  Parser.prototype.suffixesToPrefixes = function(tokens) {
    var movePrefix;
    movePrefix = function(tokens, suffixOp) {
      var ret, token;
      ret = [];
      while (tokens.length > 0) {
        token = tokens.pop();
        if (token.type === "operator" && token.value in OPERATORS.suffix) {
          token.opType = "suffix";
          ret.unshift(movePrefix(tokens, token));
        } else if (typeof suffixOp === "undefined") {
          ret.unshift(token);
        } else {
          if (token.type === "operator") {
            if (greaterPrecidence(token, suffixOp)) {
              ret.unshift(token);
              ret = movePrefix(tokens, suffixOp).concat(ret);
            } else {
              tokens.push(token);
              ret.unshift(suffixOp);
            }
            return ret;
          }
          if (tokens.length > 0 && tokens[tokens.length - 1].type === "operator" && greaterPrecidence(tokens[tokens.length - 1], suffixOp)) {
            ret.unshift(token);
            ret.unshift(tokens.pop());
          } else {
            ret.unshift(token);
            ret.unshift(suffixOp);
            return ret;
          }
        }
      }
      if (typeof suffixOp !== "undefined") {
        ret.unshift(suffixOp);
      }
      return ret;
    };
    return movePrefix(deepcopy(tokens));
  };

  Parser.prototype.computeASTForm = function(tokens) {
    var treeize;
    treeize = function(tokens, operator) {
      var ret, token;
      ret = [];
      while (tokens.length > 0) {
        token = tokens.shift();
        if (token.type === "number") {
          ret.push(token);
        } else if (token instanceof Array) {
          ret = ret.concat(treeize(token));
        } else if (token.type === "operator") {
          if (ret.length === 0) {
            token.opType = "prefix";
            if (token.value === "-") {
              token.value = "negate";
            }
            ret.push(new Node("operator", token, treeize(tokens, token)));
          } else if (greaterPrecidence(token, operator)) {
            token.opType = "infix";
            ret = [new Node("operator", token, ret.concat(treeize(tokens, token)))];
          } else {
            tokens.unshift(token);
            return ret;
          }
        }
      }
      return ret;
    };
    return treeize(deepcopy(tokens));
  };

  Parser.prototype.computeBracketTree = function(tokens) {
    var treeize;
    treeize = function(tokens, closingBracket) {
      var ret, token;
      ret = [];
      while (tokens.length > 0) {
        token = tokens.shift();
        if (token.value === closingBracket) {
          return ret;
        } else if (token.type === "bracket") {
          closingBracket = {
            "(": ")",
            "{": "}",
            "[": "]"
          }[token.value];
          ret.push(treeize(tokens, closingBracket));
        } else {
          ret.push(token);
        }
      }
      return ret;
    };
    return treeize(deepcopy(tokens));
  };

  Parser.prototype.insertImplicitMultiplication = function(tokens) {
    var insertMul, shouldInsertBeforeNextToken;
    shouldInsertBeforeNextToken = function(tokens) {
      if (tokens.length === 0) {
        return false;
      }
      if ((tokens[0] instanceof Array) || (tokens[0].type === "number") || (tokens[0].opType === "prefix" && tokens[0].type === "operator")) {
        return true;
      }
      return false;
    };
    insertMul = function(tokens) {
      var ret, token;
      ret = [];
      while (tokens.length > 0) {
        token = tokens.shift();
        if ((token.type === "number" || (token.type === "operator" && token.value in OPERATORS.suffix)) && shouldInsertBeforeNextToken(tokens)) {
          ret.push(token);
          ret.push(new Token("operator", "*", -1));
        } else if (token instanceof Array) {
          ret.push(insertMul(token));
          if (shouldInsertBeforeNextToken(tokens)) {
            ret.push(new Token("operator", "*", -1));
          }
        } else {
          ret.push(token);
        }
      }
      if (tokens.length > 0) {
        ret.push(tokens[0]);
      }
      return ret;
    };
    return insertMul(deepcopy(tokens));
  };

  return Parser;

})();
