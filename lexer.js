// Generated by CoffeeScript 1.3.1
/*
   Lexer for math expressions

   Copyright (C) 2012  Jason Siefken

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

var Lexer, TOKENS, Token, isWhiteSpace, max, startsWith,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

TOKENS = {
  operators: {
    "+": true,
    "-": true,
    "*": true,
    "/": true,
    "//": true,
    "^": true,
    "=": true,
    "!": true,
    "==": true,
    "<": true,
    "<=": true,
    ">": true,
    ">=": true,
    "!=": true,
    ",": true,
    deg: true,
    "%": true
  },
  brackets: {
    "(": true,
    ")": true,
    "[": true,
    "]": true,
    "{": true,
    "}": true
  }
};

max = function(l) {
  var i, ret, _i, _len, _ref;
  ret = l[0];
  _ref = l.slice(1);
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    i = _ref[_i];
    ret = Math.max(ret, i);
  }
  return ret;
};

isWhiteSpace = function(ch) {
  return (ch === '\u0009') || (ch === ' ') || (ch === '\u00A0');
};

startsWith = function(source, substr) {
  var k, m, matches, prefix, ret, _i, _j, _len, _len1, _ref;
  if (substr instanceof Array) {
    for (_i = 0, _len = substr.length; _i < _len; _i++) {
      prefix = substr[_i];
      if (prefix === source.slice(0, (prefix.length - 1) + 1 || 9e9)) {
        return prefix;
      }
    }
  } else if (typeof substr === "object") {
    matches = (function() {
      var _results;
      _results = [];
      for (k in substr) {
        if (k === source.slice(0, (k.length - 1) + 1 || 9e9)) {
          _results.push(k);
        }
      }
      return _results;
    })();
    ret = matches[0];
    _ref = matches.slice(1);
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      m = _ref[_j];
      if (m.length > ret.length) {
        ret = m;
      }
    }
    return ret;
  } else {
    if (substr === source.slice(0, (substr.length - 1) + 1 || 9e9)) {
      return substr;
    }
  }
  return false;
};

Token = (function() {

  Token.name = 'Token';

  function Token(type, value, position) {
    this.type = type;
    this.value = value;
    this.position = position;
    if (this.type === "number" && typeof this.value === "string") {
      switch (this.value.charAt(1)) {
        case 'x':
          this.value = parseInt(this.value.slice(2), 16);
          break;
        case 'b':
          this.value = parseInt(this.value.slice(2), 2);
          break;
        case 'o':
          this.value = parseInt(this.value.slice(2), 8);
          break;
        default:
          this.value = parseFloat(value);
      }
    }
  }

  Token.prototype.toString = function() {
    return "'" + this.value + "'";
  };

  return Token;

})();

Lexer = (function() {

  Lexer.name = 'Lexer';

  function Lexer(source) {
    this.source = source;
    this.eatWhitespace = __bind(this.eatWhitespace, this);

    this.getIdentifier = __bind(this.getIdentifier, this);

    this.getNumber = __bind(this.getNumber, this);

    this.getBracket = __bind(this.getBracket, this);

    this.getOperator = __bind(this.getOperator, this);

    this.index = 0;
  }

  Lexer.prototype.get = function() {
    var func, token, tokenString, tokenType, _i, _len, _ref, _ref1;
    this.eatWhitespace();
    tokenString = void 0;
    token = null;
    _ref = [["operator", this.getOperator], ["bracket", this.getBracket], ["number", this.getNumber], ["identifier", this.getIdentifier]];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], tokenType = _ref1[0], func = _ref1[1];
      tokenString = func();
      if (tokenString) {
        token = new Token(tokenType, tokenString, this.index);
        break;
      }
    }
    if (token) {
      this.index += tokenString.length;
    }
    return token;
  };

  Lexer.prototype.getOperator = function(pos, source) {
    if (pos == null) {
      pos = this.index || 0;
    }
    if (source == null) {
      source = this.source;
    }
    return startsWith(source.slice(pos), TOKENS.operators) || null;
  };

  Lexer.prototype.getBracket = function(pos, source) {
    pos = pos || this.index || 0;
    source = source || this.source;
    return startsWith(source.slice(pos), TOKENS.brackets) || null;
  };

  Lexer.prototype.getNumber = function(pos, source) {
    var currPos, currSource, match;
    currPos = pos || this.index || 0;
    currSource = source || this.source;
    currSource = currSource.slice(currPos);
    match = currSource.match(/^0x[0-9A-Fa-f]+/);
    if (match) {
      return match[0];
    }
    match = currSource.match(/^0b[01]+/);
    if (match) {
      return match[0];
    }
    match = currSource.match(/^0o[0-7]+/);
    if (match) {
      return match[0];
    }
    match = currSource.match(/^(\d+\.?\d*|\d*\.?\d+)(([eE][+-]?)?\d+)?/);
    if (match) {
      return match[0];
    }
    return null;
  };

  Lexer.prototype.getIdentifier = function(pos, source) {
    var match;
    if (pos == null) {
      pos = this.index || 0;
    }
    if (source == null) {
      source = this.source;
    }
    match = source.slice(pos).match(/^[A-Za-z]\w*/);
    if (match) {
      return match[0];
    }
    return null;
  };

  Lexer.prototype.eatWhitespace = function(pos, source) {
    if (pos == null) {
      pos = this.index || 0;
    }
    if (source == null) {
      source = this.source;
    }
    while (isWhiteSpace(source.charAt(pos))) {
      pos++;
    }
    if (arguments.length === 0) {
      this.index = pos;
    }
    return pos;
  };

  return Lexer;

})();
